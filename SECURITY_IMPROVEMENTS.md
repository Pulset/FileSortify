# 订阅系统安全改进

## 🔒 安全措施概览

### 1. 本地文件加密
- **XOR加密**：使用基于设备特征的密钥对 `subscription.json` 进行加密
- **设备绑定**：加密密钥基于主机名、用户名和应用盐值生成
- **透明处理**：应用自动处理加密/解密，用户无感知

### 2. 数据完整性验证
- **字段一致性检查**：验证订阅状态与相关字段的逻辑关系
- **时间戳验证**：检查试用开始时间、订阅时间的合理性
- **交易ID验证**：激活状态必须有对应的交易ID

### 3. 服务端验证
- **复用现有逻辑**：利用 `check_creem_payment_status` 进行服务端验证
- **状态同步**：定期检查本地状态与服务端状态的一致性
- **篡改检测**：发现不一致时自动降级为过期状态

### 4. 离线容错机制
- **72小时缓存**：网络错误时允许72小时离线使用
- **渐进式验证**：优先本地验证，网络可用时进行服务端验证

## 🛠️ 开发工具

### 重置订阅状态
```bash
# 查看当前状态
node reset-subscription.cjs status

# 重置为试用期（用于测试购买流程）
node reset-subscription.cjs reset

# 加密现有未加密文件
node reset-subscription.cjs encrypt
```

### 测试加密功能
```bash
node test-encryption.cjs
```

## 📋 API 变更

### 新增 Tauri 命令
- `can_use_app_secure()` - 包含服务端验证的安全权限检查

### 新增 Rust 方法
- `verify_subscription_integrity()` - 本地数据完整性验证
- `verify_data_integrity()` - 扩展的数据验证（包含时间戳检查）
- `verify_with_server()` - 服务端状态验证（复用 Creem 逻辑）
- `encrypt_data()` / `decrypt_data()` - 数据加密/解密
- `get_encryption_key()` - 基于设备特征生成密钥

## 🔄 工作流程

### 应用启动时
1. 读取加密的订阅文件
2. 解密并验证数据完整性
3. 如果数据被篡改，重置为试用状态

### 权限检查时
1. 本地完整性验证
2. 如果是激活状态，进行服务端验证
3. 网络错误时允许短期离线使用

### 订阅激活时
1. 通过 Creem 支付流程
2. 服务端确认支付状态
3. 本地加密保存订阅信息

## 🚀 部署建议

### 立即实施
1. 使用重置脚本恢复试用状态进行测试
2. 验证加密功能正常工作

### 短期目标
1. 部署服务端验证 API
2. 监控订阅验证日志

### 长期优化
1. 考虑更强的加密算法（如 AES）
2. 添加硬件指纹验证
3. 实现订阅状态的定期自动验证

## ⚠️ 注意事项

1. **向后兼容**：代码同时支持加密和未加密文件
2. **用户体验**：网络问题不会立即阻止应用使用
3. **开发便利**：提供了完整的测试和重置工具
4. **安全平衡**：在安全性和可用性之间找到平衡点

## 🔍 安全级别评估

- **基础防护** ✅ 防止普通用户直接修改JSON文件
- **中级防护** ✅ 设备绑定，防止简单的文件复制
- **高级防护** ⚠️ 对于专业逆向工程仍有风险
- **企业级防护** ❌ 需要更复杂的硬件/服务端验证方案

当前实现适合大多数桌面应用的安全需求，能有效防止普通用户的篡改行为。